{
  "version": 3,
  "file": "ngx-logger.umd.min.js",
  "sources": [
    "ng://ngx-logger/src/lib/http.service.ts",
    "ng://ngx-logger/src/lib/logger.config.ts",
    "ng://ngx-logger/src/lib/config.engine.ts",
    "ng://ngx-logger/src/lib/utils/logger.utils.ts",
    "ng://ngx-logger/src/lib/logger.service.ts",
    "ng://ngx-logger/src/lib/custom-logger.service.ts",
    "ng://ngx-logger/src/lib/types/http-meta-data.interface.ts",
    "ng://ngx-logger/src/lib/logger.module.ts",
    "ng://ngx-logger/src/lib/testing/logger.service.mock.ts",
    "ng://ngx-logger/src/lib/testing/custom-logger.service.mock.ts",
    "ng://ngx-logger/src/lib/testing/http.service.mock.ts"
  ],
  "sourcesContent": [
    "import {Injectable} from '@angular/core';\nimport {HttpClient, HttpHeaders} from '@angular/common/http';\nimport {Observable} from 'rxjs';\nimport {HttpMetaDataInterface} from './types/http-meta-data.interface';\n\n\n@Injectable()\nexport class NGXLoggerHttpService {\n  constructor(private readonly http: HttpClient) {\n\n  }\n\n  logOnServer(url: string, message: string, additional: any[], metaData: HttpMetaDataInterface): Observable<any> {\n    const body = {\n      message: message,\n      additional: additional,\n      level: metaData.level,\n      timestamp: metaData.timestamp,\n      fileName: metaData.fileName,\n      lineNumber: metaData.lineNumber\n    };\n\n    const options = {\n      headers: new HttpHeaders().set('Content-Type', 'application/json')\n    };\n\n    return this.http.post(url, body, options)\n  }\n}\n",
    "import {NgxLoggerLevel} from './types/logger-level.enum';\n\nexport class LoggerConfig {\n  level: NgxLoggerLevel;\n  serverLogLevel?: NgxLoggerLevel;\n  serverLoggingUrl?: string;\n}\n",
    "import {LoggerConfig} from './logger.config';\n\nexport class NGXLoggerConfigEngine {\n\n  private _config;\n  constructor(readonly config: LoggerConfig) {\n    this._config = config;\n  }\n\n  updateConfig(config: LoggerConfig) {\n    this._config = config;\n  }\n\n  getConfig() {\n    return this._config;\n  }\n}",
    "import {NgxLoggerLevel} from '../types/logger-level.enum';\n\nexport class NGXLoggerUtils {\n\n  static prepareMetaString(timestamp: string, logLevel: string, fileName: string, lineNumber: string) {\n    const fileDetails = fileName ? ` [${fileName}:${lineNumber}]` : '';\n\n    return `${timestamp} ${logLevel}${fileDetails}`;\n  }\n\n  static getColor(level: NgxLoggerLevel): 'blue' | 'teal' | 'gray' | 'red' | undefined {\n    switch (level) {\n      case NgxLoggerLevel.TRACE:\n        return 'blue';\n      case NgxLoggerLevel.DEBUG:\n        return 'teal';\n      case NgxLoggerLevel.INFO:\n      case NgxLoggerLevel.LOG:\n        return 'gray';\n      case NgxLoggerLevel.WARN:\n      case NgxLoggerLevel.ERROR:\n        return 'red';\n      case NgxLoggerLevel.OFF:\n      default:\n        return;\n    }\n  }\n\n\n\n  /**\n   *  This allows us to see who called the logger\n   *  @return {string}\n   *  @private\n   */\n  static getCallerDetails(): {lineNumber: string, fileName: string} {\n    const err = (new Error(''));\n\n    try {\n      // this should produce the line which NGX Logger was called\n      const callerLine = err.stack.split('\\n')[4].split('/');\n\n      // returns the file:lineNumber\n      const fileLineNumber = callerLine[callerLine.length - 1].replace(/[)]/g, '').split(':');\n\n      return {\n        fileName: fileLineNumber[0],\n        lineNumber: fileLineNumber[1]\n      }\n    } catch(e) {\n      return {\n        fileName: null,\n        lineNumber: null\n      }\n    }\n\n  }\n\n  static prepareMessage(message) {\n    try {\n       if (typeof message !== 'string' && !(message instanceof Error)) {\n        message = JSON.stringify(message, null, 2);\n      }\n    } catch (e) {\n      // additional = [message, ...additional];\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\n    }\n\n    return message;\n  }\n\n  static prepareAdditionalParameters(additional: any[]) {\n    if (additional === null || additional === undefined) {\n      return null;\n    }\n\n    return additional.map((next, idx) => {\n      try {\n        // We just want to make sure the JSON can be parsed, we do not want to actually change the type\n        if (typeof next === 'object') {\n          JSON.stringify(next)\n        }\n\n        return next;\n      } catch (e) {\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`\n      }\n    });\n  }\n\n}\n",
    "import {Inject, Injectable, PLATFORM_ID} from '@angular/core';\nimport {HttpErrorResponse} from '@angular/common/http';\nimport {isPlatformBrowser} from '@angular/common';\n\nimport {NGXLoggerHttpService} from './http.service';\nimport {NgxLoggerLevel} from './types/logger-level.enum';\nimport {LoggerConfig} from './logger.config';\nimport {NGXLoggerConfigEngine} from './config.engine';\nimport {NGXLoggerUtils} from './utils/logger.utils';\nimport {HttpMetaDataInterface} from './types/http-meta-data.interface';\n\nexport const Levels = [\n  'TRACE',\n  'DEBUG',\n  'INFO',\n  'LOG',\n  'WARN',\n  'ERROR',\n  'OFF'\n];\n\n\n@Injectable()\nexport class NGXLogger {\n  private _isIE: boolean;\n  private configService: NGXLoggerConfigEngine;\n\n\n  constructor(private readonly httpService: NGXLoggerHttpService, loggerConfig: LoggerConfig,\n              @Inject(PLATFORM_ID) private readonly platformId) {\n    this._isIE = isPlatformBrowser(platformId) &&\n      !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\n\n    // each instance of the logger should have their own config engine\n    this.configService = new NGXLoggerConfigEngine(loggerConfig);\n  }\n\n  public trace(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.TRACE, message, additional);\n  }\n\n  public debug(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\n  }\n\n  public info(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.INFO, message, additional);\n  }\n\n  public log(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.LOG, message, additional);\n  }\n\n  public warn(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.WARN, message, additional);\n  }\n\n  public error(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.ERROR, message, additional);\n  }\n\n  public updateConfig(config: LoggerConfig) {\n    this.configService.updateConfig(config);\n  }\n\n  private _logIE(level: NgxLoggerLevel, metaString: string, message: string, additional: any[]): void {\n\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    additional = additional || [];\n\n    switch (level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`${metaString} `, message, ...additional);\n        break;\n      case NgxLoggerLevel.ERROR:\n        console.error(`${metaString} `, message, ...additional);\n        break;\n      case NgxLoggerLevel.INFO:\n        console.info(`${metaString} `, message, ...additional);\n        break;\n      default:\n        console.log(`${metaString} `, message, ...additional);\n    }\n  }\n\n  private _log(level: NgxLoggerLevel, message, additional: any[] = [], logOnServer: boolean = true): void {\n    if (!message) {\n      return;\n    }\n\n    const logLevelString = Levels[level];\n\n    message = NGXLoggerUtils.prepareMessage(message);\n\n    // only use validated parameters for HTTP requests\n    const validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);\n\n    const timestamp = new Date().toISOString();\n    const config = this.configService.getConfig();\n\n    const callerDetails = NGXLoggerUtils.getCallerDetails();\n\n    if (logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel) {\n\n      const metaData: HttpMetaDataInterface = {\n        level: level,\n        timestamp: timestamp,\n        fileName: callerDetails.fileName,\n        lineNumber: callerDetails.lineNumber,\n      };\n\n      // make sure the stack gets sent to the server\n      message = message instanceof Error ? message.stack : message;\n\n      // Allow logging on server even if client log level is off\n      this.httpService.logOnServer(config.serverLoggingUrl, message, validatedAdditionalParameters, metaData).subscribe((res: any) => {\n          // I don't think we should do anything on success\n        },\n        (error: HttpErrorResponse) => {\n          this._log(NgxLoggerLevel.ERROR, `FAILED TO LOG ON SERVER: ${message}`, [error], false);\n        }\n      );\n    }\n\n\n    // if no message or the log level is less than the environ\n    if (level < config.level) {\n      return;\n    }\n\n    const metaString = NGXLoggerUtils.prepareMetaString(timestamp, logLevelString, callerDetails.fileName, callerDetails.lineNumber);\n\n    // Coloring doesn't work in IE\n    if (this._isIE) {\n      return this._logIE(level, metaString, message, additional);\n    }\n\n    const color = NGXLoggerUtils.getColor(level);\n\n    console.log(`%c${metaString}`, `color:${color}`, message, ...(additional || []));\n  }\n}\n",
    "import {Inject, Injectable, PLATFORM_ID} from '@angular/core';\n\nimport {LoggerConfig} from './logger.config';\nimport {NGXLoggerHttpService} from './http.service';\nimport {NGXLogger} from './logger.service';\n\n\n/**\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\n */\n@Injectable()\nexport class CustomNGXLoggerService {\n\n  constructor(private readonly httpService: NGXLoggerHttpService,\n              @Inject(PLATFORM_ID) private readonly platformId) {\n  }\n\n  create(config: LoggerConfig, httpService?: NGXLoggerHttpService): NGXLogger {\n    // you can inject your own httpService or use the default,\n    return new NGXLogger(httpService || this.httpService, config, this.platformId);\n  }\n}\n\n\n",
    "import {NgxLoggerLevel} from './logger-level.enum';\n\nexport class HttpMetaDataInterface {\n  level: NgxLoggerLevel;\n  timestamp: string;\n  fileName: string;\n  lineNumber: string;\n}\n",
    "import {CommonModule} from '@angular/common';\nimport {HttpClientModule} from '@angular/common/http';\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {NGXLogger} from './logger.service';\nimport {LoggerConfig} from './logger.config';\nimport {CustomNGXLoggerService} from './custom-logger.service';\nimport {NGXLoggerHttpService} from './http.service';\n\nexport * from './logger.service';\n\nexport * from './logger.config';\n\nexport * from './custom-logger.service';\n\nexport * from './http.service';\n\nexport * from './utils/logger.utils';\nexport * from './types/logger-level.enum';\nexport * from './types/http-meta-data.interface';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    HttpClientModule\n  ],\n  providers: [\n    NGXLogger,\n    NGXLoggerHttpService,\n    CustomNGXLoggerService\n  ]\n})\nexport class LoggerModule {\n  static forRoot(config: LoggerConfig | null | undefined): ModuleWithProviders {\n    return {\n      ngModule: LoggerModule,\n      providers: [\n        {provide: LoggerConfig, useValue: config || {}},\n        NGXLogger,\n        NGXLoggerHttpService,\n        CustomNGXLoggerService\n      ]\n    };\n  }\n  static forChild(): ModuleWithProviders {\n    return {\n      ngModule: LoggerModule,\n      providers: [\n        NGXLogger,\n        NGXLoggerHttpService,\n        CustomNGXLoggerService\n      ]\n    };\n  }\n}\n",
    "\nexport class NGXLoggerMock {\n\n  constructor() {\n  }\n\n  trace(message: any, ...additional: any[]) {\n  }\n\n  debug(message: any, ...additional: any[]) {\n  }\n\n  info(message: any, ...additional: any[]) {\n  }\n\n  log(message: any, ...additional: any[]) {\n  }\n\n  warn(message: any, ...additional: any[]) {\n  }\n\n  error(message: any, ...additional: any[]) {\n  }\n\n  updateConfig(config: any) {\n\n  }\n}\n",
    "import {NGXLoggerMock} from './logger.service.mock';\n\n/**\n * CustomNGXLoggerServiceMock is a mock for CustomNGXLoggerService\n */\nexport class CustomNGXLoggerServiceMock {\n\n  constructor() {\n  }\n\n  create(): NGXLoggerMock {\n    // you can inject your own httpService or use the default,\n    return new NGXLoggerMock();\n  }\n}\n\n\n",
    "import {Observable, of} from 'rxjs';\n\nexport class NGXLoggerHttpServiceMock {\n  constructor() {\n\n  }\n\n  logOnServer(url: string, message: string, additional: any[], timestamp: string, logLevel: string): Observable<any> {\n    return of({})\n  }\n}\n"
  ],
  "names": [
    "NGXLoggerHttpService",
    "http",
    "this",
    "prototype",
    "logOnServer",
    "url",
    "message",
    "additional",
    "metaData",
    "body",
    "level",
    "timestamp",
    "fileName",
    "lineNumber",
    "options",
    "headers",
    "HttpHeaders",
    "set",
    "post",
    "LoggerConfig",
    "NGXLoggerConfigEngine",
    "config",
    "_config",
    "updateConfig",
    "getConfig",
    "NGXLoggerUtils",
    "prepareMetaString",
    "logLevel",
    "getColor",
    "NgxLoggerLevel",
    "TRACE",
    "DEBUG",
    "INFO",
    "LOG",
    "WARN",
    "ERROR",
    "OFF",
    "getCallerDetails",
    "callerLine",
    "err",
    "stack",
    "split",
    "fileLineNumber",
    "length",
    "replace",
    "e",
    "prepareMessage",
    "Error",
    "JSON",
    "stringify",
    "prepareAdditionalParameters",
    "undefined",
    "next",
    "idx",
    "Levels",
    "NGXLogger",
    "httpService",
    "loggerConfig",
    "platformId",
    "_isIE",
    "isPlatformBrowser",
    "configService",
    "trace",
    "_i",
    "arguments",
    "info",
    "error",
    "_log",
    "_logIE",
    "metaString",
    "console",
    "apply",
    "tslib_1.__spread",
    "log",
    "_this",
    "validatedAdditionalParameters",
    "Date",
    "toISOString",
    "CustomNGXLoggerService",
    "create",
    "ctorParameters",
    "HttpMetaDataInterface",
    "LoggerModule",
    "forRoot",
    "ngModule",
    "providers",
    "provide",
    "useValue",
    "forChild",
    "decorators",
    "type",
    "NgModule",
    "args",
    "imports",
    "CommonModule",
    "HttpClientModule",
    "NGXLoggerMock",
    "CustomNGXLoggerServiceMock",
    "NGXLoggerHttpServiceMock",
    "of"
  ],
  "mappings": "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"
}
